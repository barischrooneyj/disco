#+title: disco
#+OPTIONS: toc:nil

- A *dis* tributed systems management *co* nsole.
 
Manage networks of nodes running across services.
 
- A distributed algorithms research tool.
 
Quickly launch, analyse and iterate on algorithms.

- A high level distributed data library.

Explore abstractions of distributed data, like DSTM and DFRP.

* Overview

** Node
   
The definition of a node is given below. I recommend looking at [[src/Network.hs]]
for the most important definitions used by this library. The file is quite short
and nothing fancy is going on.

#+begin_src haskell
-- | A node is an independent system in a network.
data Node = Node {
  -- ^ A unique identifier.
  _id     :: NodeID,
  -- ^ The program to run.
  _exe    :: Exe,
  -- ^ Where to start the node.
  _launch :: Launch,
  -- ^ Information to enable high-level messaging.
  _messaging :: Messaging
}
#+end_src

Nodes can be started based on the given =Launch= information, currently we only
support starting a node on a local Docker container (one per node) but starting
nodes on other services is a main goal. When we talk of starting a node we mean
executing a small boot program somewhere which is passed the =NodeID=, =Exe=,
and =Messaging= information.

The =Exe= information describes which program to run, currently we only support
running a default executable, which you can find in the folder =disco-docker=.
We would like to support installation from Hackage, GitHub etc. and to support
binaries (maybe start with Docker Hub).

The =Messaging= information configures a transport layer for the use of
high-level messaging functions that the disco library provides, such as
=neighbours=. The use of this transport layer allows us to implement an
artificial network topology and analyze network characteristics such as
message/bit complexity.

** Network
   
We define a network as consisting of nodes and edges. The edges define an
artificial network topology. The =Launch= information of a node controls where
it runs, and thus the physical network topology. When we talk simply of "network
topology" we mean the artificial network topology.

#+begin_src haskell
data Network = Network { _nodes :: [Node], _edges :: Edges }
#+end_src

The =Edges= field provides us with the option of specifying the network
topology. Either as a set of edges or as a network topology shorthand. The
following code shows the specification of a simple ring consisting of five of
the same node. The node simply prints hello world and is started on a local
Docker container.

#+begin_src haskell
exampleNetwork = Network { _nodes = replicate 5 helloWorldOnDocker, _edges = Ring }
#+end_src

* Aims
   
The overview above has described the core (and very simple architecture) of what
is necessary to support the three aims at the top of this file. To support the
management console aim we need to support the modification of the network, and
provide a graphical layer (maybe with [[https://hackage.haskell.org/package/brick][brick]] including a network overview/map).

To reach the distributed algorithms research goal we just need to implement some
algorithms. Doing so will reveal the building blocks we need, functions like
=neighbours=, which returns a node's neighbours IDs. We can explore different
abstractions for writing distributed algorithms. Perhaps start with a simple
ring election algorithm maybe. For message passing, the integration of an
Erlang-style message passing library like [[https://hackage.haskell.org/package/courier][courier]] may be useful.

Regarding the final aim we would like to provide abstractions/examples for
dealing with distributed data. Distributed STM exists, can we integrate it,
should we? What about distributed FRP as hinted at recently on this reddit
[[https://www.reddit.com/r/haskell/comments/8g73hv/reactivebanana_or_other_frp_lib_for_networking/][thread]]. What about decentralized data?

* Other Libraries

Cloud Haskell and transient seem to be in a similar domain as disco. Though
disco has a distinct focus on distributed algorithms research. Furthermore disco
maintains a more simple semantic model of the network, and this simplicity is
reflected in our data types. We aim to offload a lot of functionality, such as
Erlang-style message passing, to third-party libraries like courier.

Distributed programming is given a rating of immature in the [[https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#distributed-programming][state of the
Haskell ecosystem ]]document. Quoting from the same document: "Work on the
higher-level libraries seems to have stopped, but the low-level libraries are
still good for distributing computation." and "We need more analytics
libraries".

* Installing and running

Install [[https://www.docker.com/get-docker][Docker]], [[https://docs.docker.com/compose][Docker Compose]], [[https://docs.haskellstack.org/en/stable/README][Stack]]. On macOS you can do:

#+begin_src bash
  brew cask install docker
  brew install docker-compose haskell-stack
#+end_src

Clone the project and install Haskell dependencies:

#+begin_src bash
  git clone git@github.com:barischrooneyj/disco && cd disco
  stack build --install-ghc
#+end_src

Start the Docker daemon, on macOS this is:

#+begin_src bash
  open -a docker
#+end_src

Open the disco console:

#+begin_src bash
  stack exec disco
#+end_src
